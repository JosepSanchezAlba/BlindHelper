<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>YOLOv8s OpenImages - C치mara</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
  <style>
    body { text-align: center; font-family: sans-serif; }
    canvas { border: 2px solid black; width: 90vw; max-width: 480px; height: auto; aspect-ratio: 4/3; }
    #video { display: none; }
    select, button { margin: 10px; font-size: 16px; padding: 5px; }
  </style>
</head>
<body>
  <h2>YOLOv8 OpenImages</h2>
  <select id="cameraSelect"></select>
  <button onclick="startCamera()">Iniciar</button>
  <br>
  <canvas id="canvas" width="640" height="480"></canvas>
  <p id="status">Esperando modelo...</p>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const video = document.createElement('video');
    video.setAttribute('playsinline', '');
    video.setAttribute('autoplay', '');
    video.setAttribute('muted', '');
    video.style.display = 'none';
    document.body.appendChild(video);

    let session;
    let classNames = []; // se cargar치 aparte

    async function loadModel() {
      session = await ort.InferenceSession.create("yolov8s-oiv7.onnx");
      document.getElementById('status').innerText = "Modelo cargado. Selecciona c치mara.";
    }

    async function getCameras() {
      const devices = await navigator.mediaDevices.enumerateDevices();
      const cams = devices.filter(d => d.kind === 'videoinput');
      const select = document.getElementById('cameraSelect');
      select.innerHTML = "";
      cams.forEach((cam, i) => {
        const opt = document.createElement('option');
        opt.value = cam.deviceId;
        opt.text = cam.label || `C치mara ${i + 1}`;
        select.appendChild(opt);
      });
    }

    async function startCamera() {
      const deviceId = document.getElementById('cameraSelect').value;
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { deviceId: { exact: deviceId } }, audio: false
      });
      video.srcObject = stream;
      await video.play();

      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      detectLoop();
    }

    function preprocess(video) {
      const size = 640;
      const tempCanvas = document.createElement("canvas");
      tempCanvas.width = size;
      tempCanvas.height = size;
      const tempCtx = tempCanvas.getContext("2d");
      tempCtx.drawImage(video, 0, 0, size, size);
      const imgData = tempCtx.getImageData(0, 0, size, size);
      const input = new Float32Array(size * size * 3);
      for (let i = 0; i < size * size; i++) {
        input[i] = imgData.data[i * 4] / 255;
        input[i + size * size] = imgData.data[i * 4 + 1] / 255;
        input[i + 2 * size * size] = imgData.data[i * 4 + 2] / 255;
      }
      return new ort.Tensor("float32", input, [1, 3, size, size]);
    }

    function drawBoxes(boxes) {
      ctx.save();
      ctx.scale(-1, 1);  // flip horizontal
      ctx.drawImage(video, -canvas.width, 0, canvas.width, canvas.height);
      ctx.restore();

      boxes.forEach(([x1, y1, x2, y2, score, classId]) => {
        if (score < 0.5) return;
        ctx.strokeStyle = "red";
        ctx.lineWidth = 2;
        ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
        ctx.fillStyle = "red";
        ctx.font = "14px Arial";
        ctx.fillText(`${classNames[classId]} ${(score * 100).toFixed(1)}%`, x1 + 2, y1 + 14);
      });
    }

    async function detectLoop() {
      if (!session) return;
      const input = preprocess(video);
      const feeds = { images: input };
      const output = await session.run(feeds);
      const result = output[Object.keys(output)[0]].data;

      const boxes = [];
      for (let i = 0; i < result.length; i += 6) {
        boxes.push(result.slice(i, i + 6));
      }

      drawBoxes(boxes);
      requestAnimationFrame(detectLoop);
    }

    async function loadClassNames() {
      const res = await fetch("classes.txt");
      classNames = (await res.text()).split("\n").map(l => l.trim()).filter(Boolean);
    }

    loadModel();
    getCameras();
    loadClassNames();
  </script>
</body>
</html>
